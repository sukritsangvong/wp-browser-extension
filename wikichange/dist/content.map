{"version":3,"file":"content.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AENA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://wikichange/./src/content/content.js","webpack://wikichange/./src/content/enums.js","webpack://wikichange/./src/content/timeSeriesService.js","webpack://wikichange/webpack/bootstrap","webpack://wikichange/webpack/runtime/define property getters","webpack://wikichange/webpack/runtime/hasOwnProperty shorthand","webpack://wikichange/webpack/runtime/make namespace object","webpack://wikichange/webpack/before-startup","webpack://wikichange/webpack/startup","webpack://wikichange/webpack/after-startup"],"sourcesContent":["import { WIKI_CREATION_DATE, AggregateType } from \"./enums.js\";\nimport { getPageViews } from \"./timeSeriesService.js\";\n\n// Get page views for the Pasta article since its creation until the beginning of 2022 by day\nconst pastaResponse = getPageViews(\"Pasta\", WIKI_CREATION_DATE, new Date(\"2022-01-01\"), AggregateType.DAILY);\nconsole.log(pastaResponse);\n\n/* Creates the div for the graph overlay. TODO: create the graph and render it here */\nconst renderGraphOverlay = () => {\n    let graphContainer = document.createElement('div');\n    graphContainer.style.cssText = 'width:40%;height:180px;background-color:#E3C2FF;';\n\n    let p = document.createElement('p');\n    graphContainer.appendChild(p);\n    let text = document.createTextNode('The graph overlay will be here');\n    p.appendChild(text);\n\n    let siteSub = document.getElementById('siteSub');\n    siteSub.append(graphContainer);\n}\n\n// Get wikipedia text, global as we shouldn't get it every time we highlight a word \nlet wikiText = document.getElementById('mw-content-text');\nlet innerHTML = wikiText.innerHTML;\n\n/* Highlights the words that are given */\nconst highlightPersistentContent = (text, color) => {\n    let index = innerHTML.indexOf(text);\n    if (index >= 0) { \n        innerHTML = innerHTML.substring(0, index) + `<mark style='background-color: ${color}'>` + innerHTML.substring(index, index + text.length) + '</mark>' + innerHTML.substring(index + text.length);\n        wikiText.innerHTML = innerHTML;\n    }\n}\n\nrenderGraphOverlay();\n\n\n/* The page id can be found as the last part of the link to\n * the wikidata item on the left side of wikipedia pages.\n * If no page id is found throws an error.\n */\nconst pageId = (() => {\n    let wiki_data_url;\n    try {\n        wiki_data_url = document.getElementById('t-wikibase').getElementsByTagName('a')[0].href;\n    } catch {\n        throw new Error(\"'Can't find page id!\");\n    }\n    const wiki_page_id = wiki_data_url.split('/').slice(-1)[0];\n    console.info({\n        \"wiki_data_url\": wiki_data_url,\n        \"wiki_page_id\": wiki_page_id\n    });\n    return(wiki_page_id);\n})();","// Values used for timeSeriesService\r\nconst WIKI_CREATION_DATE = new Date(\"2001-01-15\"); // 15 January 2001: to fetch data since creation\r\n\r\nconst AggregateType = {\r\n    MONTHLY: \"monthly\",\r\n    DAILY: \"daily\",\r\n};\r\n\r\nexport { WIKI_CREATION_DATE, AggregateType };\r\n","import { AggregateType } from \"./enums.js\";\r\n\r\nconst formatDateToYYYMMDD = (date) =>\r\n    `${date.getFullYear()}${(\"0\" + (date.getMonth() + 1)).slice(-2)}${(\"0\" + date.getDate()).slice(-2)}`;\r\n\r\nconst formatYYYYMMDDToDate = (yyyymmdd) =>\r\n    new Date(yyyymmdd.substring(0, 4), yyyymmdd.substring(4, 6) - 1, yyyymmdd.substring(6, 8));\r\n\r\n/**\r\n * Fetches page views information on a given wikipedia title. The response will only include stat since its creation\r\n * if the startDate comes before the article was created.\r\n *\r\n * @param {string} title of a wikipedia article\r\n * @param {Date} startDate\r\n * @param {Date} endDate\r\n * @param {string} aggregateType of either monthly or daily\r\n * @return {map} of an item of an array with properties project, article, granularity(aggregateType), timestamp, access, agent, views\r\n */\r\nconst fetchPageViews = async (title, startDate, endDate, aggregateType) => {\r\n    const formattedStartDate = formatDateToYYYMMDD(startDate);\r\n    const formattedEndDate = formatDateToYYYMMDD(endDate);\r\n    const response = await fetch(\r\n        `https://wikimedia.org/api/rest_v1/metrics/pageviews/per-article/en.wikipedia/all-access/all-agents/${title}/${aggregateType}/${formattedStartDate}/${formattedEndDate}`\r\n    );\r\n    return await response.json();\r\n};\r\n\r\n/**\r\n * Get all the revision objects on a given wikipedia title.\r\n *\r\n * The api only gives us at most 20 reivision objects per request. However, it does give us a query to\r\n * use if there are any older revisions. If older versions of revision exists, we will get\r\n * {\r\n *  revisions: [...],\r\n *  ...\r\n *  older: 'https://en.wikipedia.org/w/rest.php/v1/page/Jupiter/history?older_than=1103899458',\r\n *  ...\r\n * }\r\n *\r\n * Thus, we keep calling the endpoint with the given query if the older property exists in the\r\n * previous request.\r\n *\r\n * @param {string} title of a wikipedia article\r\n * @param {Date} startDate\r\n * @param {Date} endDate\r\n * @returns An array containing all revision objects\r\n */\r\nconst fetchPageRevisions = async (title, startDate, endDate) => {\r\n    const response = await fetch(`https://en.wikipedia.org/w/rest.php/v1/page/${title}/history`);\r\n    let curJsonResponse = await response.json();\r\n\r\n    let revisions = curJsonResponse.revisions;\r\n\r\n    while (curJsonResponse.hasOwnProperty(\"older\")) {\r\n        const localResponse = await fetch(curJsonResponse.older);\r\n        curJsonResponse = await localResponse.json();\r\n\r\n        const localRevisions = curJsonResponse.revisions;\r\n\r\n        // Stop making requests when requesting passes startDate\r\n        const localLatestTimestamp = new Date(localRevisions[0].timestamp);\r\n        if (localLatestTimestamp < startDate) break;\r\n\r\n        revisions.push(...localRevisions);\r\n    }\r\n\r\n    // Filters revisions that are in between the given timerange\r\n    return revisions.filter((revisionObject) => {\r\n        const currentTimestamp = new Date(revisionObject.timestamp);\r\n        return startDate <= currentTimestamp && currentTimestamp <= endDate;\r\n    });\r\n};\r\n\r\n/**\r\n * TODO: Subject to change based on what the graph needs\r\n * @return formated fetchedPageViews as an array of arrays that only contain date object and count\r\n */\r\nconst formatPageViews = (fetchedPageViews) => {\r\n    return Array.from(fetchedPageViews.items).map((pageViewObject) => {\r\n        return [formatYYYYMMDDToDate(pageViewObject.timestamp), pageViewObject.views];\r\n    });\r\n};\r\n\r\n/**\r\n * TODO: Subject to change based on what the graph needs\r\n * @param {AggregateType} aggregateType\r\n * @return formated fetchedRevisions as an array of arrays that only contain date object and count\r\n */\r\nconst formatPageRevisions = (fetchedRevisions, aggregateType) => {\r\n    const pageRevisionCountMap = fetchedRevisions\r\n        .map((revisionObject) => {\r\n            const date = new Date(revisionObject.timestamp);\r\n            date.setHours(0, 0, 0, 0); // have date only contains year, month, and day (not time)\r\n\r\n            // Set date to 1 to aggregate monthly instead of daily\r\n            if (aggregateType == AggregateType.MONTHLY) {\r\n                date.setDate(1);\r\n            }\r\n\r\n            return date;\r\n        })\r\n        .reduce((accumulator, timestamp) => {\r\n            accumulator[timestamp] = (accumulator[timestamp] ?? 0) + 1;\r\n            return accumulator;\r\n        }, {});\r\n\r\n    // Formats into an array of arrays\r\n    return Object.keys(pageRevisionCountMap).map((key) => [key, pageRevisionCountMap[key]]);\r\n};\r\n\r\n/**\r\n * Gets view counts on a given article within a given time range.\r\n *\r\n * @param {string} title of a wikipedia article\r\n * @param {Date} startDate\r\n * @param {Date} endDate\r\n * @param {AggregateType} aggregateType an enum that represents string \"monthly\" or \"daily\"\r\n * @returns aggregated array of data of views per day or per month\r\n */\r\nconst getPageViews = async (title, startDate, endDate, aggregateType) => {\r\n    try {\r\n        let result = await fetchPageViews(title, startDate, endDate, aggregateType);\r\n        let formattedResult = formatPageViews(result);\r\n        return formattedResult;\r\n    } catch (err) {\r\n        console.error(\r\n            `Error fetching page views on inputs title:${title} startDate:${startDate} endDate:${endDate} aggregateType:${aggregateType}\\nError: ${err.message}`\r\n        );\r\n        return err;\r\n    }\r\n};\r\n\r\n/**\r\n * Get revision counts on a given article within a given time range.\r\n *\r\n * @param {string} title of a wikipedia article\r\n * @param {Date} startDate\r\n * @param {Date} endDate\r\n * @param {AggregateType} aggregateType an enum that represents string \"monthly\" or \"daily\"\r\n * @returns aggregated array of data of revision counts per day or per month\r\n */\r\nconst getPageRevisionCount = async (title, startDate, endDate, aggregateType) => {\r\n    try {\r\n        let result = await fetchPageRevisions(title, startDate, endDate);\r\n        let formattedResult = formatPageRevisions(result, aggregateType);\r\n        return formattedResult;\r\n    } catch (err) {\r\n        console.error(\r\n            `Error fetching revision count on inputs title:${title} startDate:${startDate} endDate:${endDate} aggregateType:${aggregateType}\\nError: ${err.message}`\r\n        );\r\n\r\n        return err;\r\n    }\r\n};\r\n\r\nexport { getPageViews, getPageRevisionCount };\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n__webpack_require__(\"./src/content/content.js\");\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(\"./src/content/enums.js\");\nvar __webpack_exports__ = __webpack_require__(\"./src/content/timeSeriesService.js\");\n",""],"names":[],"sourceRoot":""}