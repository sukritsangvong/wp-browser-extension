{"version":3,"file":"content.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AENA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://wikichange/./src/content/content.js","webpack://wikichange/./src/content/enums.js","webpack://wikichange/./src/content/timeSeriesService.js","webpack://wikichange/webpack/bootstrap","webpack://wikichange/webpack/runtime/define property getters","webpack://wikichange/webpack/runtime/hasOwnProperty shorthand","webpack://wikichange/webpack/runtime/make namespace object","webpack://wikichange/webpack/before-startup","webpack://wikichange/webpack/startup","webpack://wikichange/webpack/after-startup"],"sourcesContent":["import { WIKI_CREATION_DATE, AggregateType } from \"./enums.js\";\nimport { getPageViews } from \"./timeSeriesService.js\";\n\n/* Creates the div for the graph overlay. TODO: create the graph and render it here */\nconst renderGraphOverlay = () => {\n    let graphContainer = document.createElement('div');\n    graphContainer.style.cssText = 'width:40%;height:180px;background-color:#E3C2FF;';\n\n    let p = document.createElement('p');\n    graphContainer.appendChild(p);\n    let text = document.createTextNode('The graph overlay will be here');\n    p.appendChild(text);\n\n    let siteSub = document.getElementById('siteSub');\n    siteSub.append(graphContainer);\n}\n\n// Get wikipedia text, global as we shouldn't get it every time we highlight a word \nlet wikiText = document.getElementById('mw-content-text');\nlet innerHTML = wikiText.innerHTML;\n\n/* Highlights the words that are given */\nconst highlightPersistentContent = (text, color) => {\n    let index = innerHTML.indexOf(text);\n    if (index >= 0) { \n        innerHTML = innerHTML.substring(0, index) + `<mark style='background-color: ${color}'>` + innerHTML.substring(index, index + text.length) + '</mark>' + innerHTML.substring(index + text.length);\n        wikiText.innerHTML = innerHTML;\n    }\n}\n\nrenderGraphOverlay();\n\n\n/* The page id can be found as the last part of the link to\n * the wikidata item on the left side of wikipedia pages.\n * If no page id is found throws an error.\n */\nconst pageId = (() => {\n    let wiki_data_url;\n    try {\n        wiki_data_url = document.getElementById('t-wikibase').getElementsByTagName('a')[0].href;\n    } catch {\n        throw new Error(\"'Can't find page id!\");\n    }\n    const wiki_page_id = wiki_data_url.split('/').slice(-1)[0];\n    console.info({\n        \"wiki_data_url\": wiki_data_url,\n        \"wiki_page_id\": wiki_page_id\n    });\n    return(wiki_page_id);\n})();","// Values used for timeSeriesService\nconst WIKI_CREATION_DATE = new Date(\"2001-01-15\"); // 15 January 2001: to fetch data since creation\n\nconst AggregateType = {\n    MONTHLY: \"monthly\",\n    DAILY: \"daily\",\n};\n\nexport { WIKI_CREATION_DATE, AggregateType };\n","import { AggregateType } from \"./enums.js\";\n\nconst formatDateToYYYMMDD = (date) =>\n    `${date.getFullYear()}${(\"0\" + (date.getMonth() + 1)).slice(-2)}${(\"0\" + date.getDate()).slice(-2)}`;\n\nconst formatYYYYMMDDToDate = (yyyymmdd) =>\n    new Date(yyyymmdd.substring(0, 4), yyyymmdd.substring(4, 6) - 1, yyyymmdd.substring(6, 8));\n\n/**\n * Fetches page views information on a given wikipedia title. The response will only include stat since its creation\n * if the startDate comes before the article was created.\n *\n * @param {string} title of a wikipedia article\n * @param {Date} startDate\n * @param {Date} endDate\n * @param {string} aggregateType of either monthly or daily\n * @return {map} of an item of an array with properties project, article, granularity(aggregateType), timestamp, access, agent, views\n */\nconst fetchPageViews = async (title, startDate, endDate, aggregateType) => {\n    const formattedStartDate = formatDateToYYYMMDD(startDate);\n    const formattedEndDate = formatDateToYYYMMDD(endDate);\n    const response = await fetch(\n        `https://wikimedia.org/api/rest_v1/metrics/pageviews/per-article/en.wikipedia/all-access/all-agents/${title}/${aggregateType}/${formattedStartDate}/${formattedEndDate}`\n    );\n    return await response.json();\n};\n\n/**\n * Get all the revision objects on a given wikipedia title.\n *\n * The api only gives us at most 20 reivision objects per request. However, it does give us a query to\n * use if there are any older revisions. If older versions of revision exists, we will get\n * {\n *  revisions: [...],\n *  ...\n *  older: 'https://en.wikipedia.org/w/rest.php/v1/page/Jupiter/history?older_than=1103899458',\n *  ...\n * }\n *\n * Thus, we keep calling the endpoint with the given query if the older property exists in the\n * previous request.\n *\n * @param {string} title of a wikipedia article\n * @param {Date} startDate\n * @param {Date} endDate\n * @returns An array containing all revision objects\n */\nconst fetchPageRevisions = async (title, startDate, endDate) => {\n    const response = await fetch(`https://en.wikipedia.org/w/rest.php/v1/page/${title}/history`);\n    let curJsonResponse = await response.json();\n\n    let revisions = curJsonResponse.revisions;\n\n    while (curJsonResponse.hasOwnProperty(\"older\")) {\n        const localResponse = await fetch(curJsonResponse.older);\n        curJsonResponse = await localResponse.json();\n\n        const localRevisions = curJsonResponse.revisions;\n\n        // Stop making requests when requesting passes startDate\n        const localLatestTimestamp = new Date(localRevisions[0].timestamp);\n        if (localLatestTimestamp < startDate) break;\n\n        revisions.push(...localRevisions);\n    }\n\n    // Filters revisions that are in between the given timerange\n    return revisions.filter((revisionObject) => {\n        const currentTimestamp = new Date(revisionObject.timestamp);\n        return startDate <= currentTimestamp && currentTimestamp <= endDate;\n    });\n};\n\n/**\n * TODO: Subject to change based on what the graph needs\n * @return formated fetchedPageViews as an array of arrays that only contain date object and count\n */\nconst formatPageViews = (fetchedPageViews) => {\n    return Array.from(fetchedPageViews.items).map((pageViewObject) => {\n        return [formatYYYYMMDDToDate(pageViewObject.timestamp), pageViewObject.views];\n    });\n};\n\n/**\n * TODO: Subject to change based on what the graph needs\n * @param {AggregateType} aggregateType\n * @return formated fetchedRevisions as an array of arrays that only contain date object and count\n */\nconst formatPageRevisions = (fetchedRevisions, aggregateType) => {\n    const pageRevisionCountMap = fetchedRevisions\n        .map((revisionObject) => {\n            const date = new Date(revisionObject.timestamp);\n            date.setHours(0, 0, 0, 0); // have date only contains year, month, and day (not time)\n\n            // Set date to 1 to aggregate monthly instead of daily\n            if (aggregateType == AggregateType.MONTHLY) {\n                date.setDate(1);\n            }\n\n            return date;\n        })\n        .reduce((accumulator, timestamp) => {\n            accumulator[timestamp] = (accumulator[timestamp] ?? 0) + 1;\n            return accumulator;\n        }, {});\n\n    // Formats into an array of arrays\n    return Object.keys(pageRevisionCountMap).map((key) => [key, pageRevisionCountMap[key]]);\n};\n\n/**\n * Gets view counts on a given article within a given time range.\n *\n * @param {string} title of a wikipedia article\n * @param {Date} startDate\n * @param {Date} endDate\n * @param {AggregateType} aggregateType an enum that represents string \"monthly\" or \"daily\"\n * @returns aggregated array of data of views per day or per month\n */\nconst getPageViews = async (title, startDate, endDate, aggregateType) => {\n    try {\n        let result = await fetchPageViews(title, startDate, endDate, aggregateType);\n        let formattedResult = formatPageViews(result);\n        return formattedResult;\n    } catch (err) {\n        console.error(\n            `Error fetching page views on inputs title:${title} startDate:${startDate} endDate:${endDate} aggregateType:${aggregateType}\\nError: ${err.message}`\n        );\n        return err;\n    }\n};\n\n/**\n * Get revision counts on a given article within a given time range.\n *\n * @param {string} title of a wikipedia article\n * @param {Date} startDate\n * @param {Date} endDate\n * @param {AggregateType} aggregateType an enum that represents string \"monthly\" or \"daily\"\n * @returns aggregated array of data of revision counts per day or per month\n */\nconst getPageRevisionCount = async (title, startDate, endDate, aggregateType) => {\n    try {\n        let result = await fetchPageRevisions(title, startDate, endDate);\n        let formattedResult = formatPageRevisions(result, aggregateType);\n        return formattedResult;\n    } catch (err) {\n        console.error(\n            `Error fetching revision count on inputs title:${title} startDate:${startDate} endDate:${endDate} aggregateType:${aggregateType}\\nError: ${err.message}`\n        );\n\n        return err;\n    }\n};\n\nexport { getPageViews, getPageRevisionCount };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n__webpack_require__(\"./src/content/content.js\");\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(\"./src/content/enums.js\");\nvar __webpack_exports__ = __webpack_require__(\"./src/content/timeSeriesService.js\");\n",""],"names":[],"sourceRoot":""}